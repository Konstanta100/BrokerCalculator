// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const AccountById = `-- name: AccountById :one
select id, user_id, name, status, type, access_level, opened_date, closed_date from investing.accounts where id = $1
`

func (q *Queries) AccountById(ctx context.Context, id string) (*Account, error) {
	row := q.db.QueryRow(ctx, AccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Status,
		&i.Type,
		&i.AccessLevel,
		&i.OpenedDate,
		&i.ClosedDate,
	)
	return &i, err
}

const AccountCreate = `-- name: AccountCreate :one
INSERT INTO investing.accounts (
    id,
    user_id,
    name,
    status,
    type,
    access_level,
    opened_date,
    closed_date
) VALUES ($1,$2,$3,$4, $5,$6,$7,$8)
RETURNING id
`

type AccountCreateParams struct {
	ID          string           `db:"id" json:"id"`
	UserID      pgtype.UUID      `db:"user_id" json:"user_id"`
	Name        string           `db:"name" json:"name"`
	Status      string           `db:"status" json:"status"`
	Type        string           `db:"type" json:"type"`
	AccessLevel string           `db:"access_level" json:"access_level"`
	OpenedDate  pgtype.Timestamp `db:"opened_date" json:"opened_date"`
	ClosedDate  pgtype.Timestamp `db:"closed_date" json:"closed_date"`
}

func (q *Queries) AccountCreate(ctx context.Context, arg AccountCreateParams) (string, error) {
	row := q.db.QueryRow(ctx, AccountCreate,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Status,
		arg.Type,
		arg.AccessLevel,
		arg.OpenedDate,
		arg.ClosedDate,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const AccountsByUserId = `-- name: AccountsByUserId :many
select id, user_id, name, status, type, access_level, opened_date, closed_date from investing.accounts where user_id = $1
`

func (q *Queries) AccountsByUserId(ctx context.Context, userID pgtype.UUID) ([]*Account, error) {
	rows, err := q.db.Query(ctx, AccountsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Status,
			&i.Type,
			&i.AccessLevel,
			&i.OpenedDate,
			&i.ClosedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type BulkInsertOperationsParams struct {
	ID             string           `db:"id" json:"id"`
	Figi           string           `db:"figi" json:"figi"`
	InstrumentType string           `db:"instrument_type" json:"instrument_type"`
	Quantity       int64            `db:"quantity" json:"quantity"`
	Payment        pgtype.Numeric   `db:"payment" json:"payment"`
	Currency       string           `db:"currency" json:"currency"`
	Date           pgtype.Timestamp `db:"date" json:"date"`
	AccountID      string           `db:"account_id" json:"account_id"`
}

const OperationCreate = `-- name: OperationCreate :one
INSERT INTO investing.operations (
    id,
    figi,
    instrument_type,
    quantity,
    payment,
    currency,
    date,
    account_id
) VALUES ($1, $2, $3, $4, $5,  $6, $7, $8)
    RETURNING id
`

type OperationCreateParams struct {
	ID             string           `db:"id" json:"id"`
	Figi           string           `db:"figi" json:"figi"`
	InstrumentType string           `db:"instrument_type" json:"instrument_type"`
	Quantity       int64            `db:"quantity" json:"quantity"`
	Payment        pgtype.Numeric   `db:"payment" json:"payment"`
	Currency       string           `db:"currency" json:"currency"`
	Date           pgtype.Timestamp `db:"date" json:"date"`
	AccountID      string           `db:"account_id" json:"account_id"`
}

func (q *Queries) OperationCreate(ctx context.Context, arg OperationCreateParams) (string, error) {
	row := q.db.QueryRow(ctx, OperationCreate,
		arg.ID,
		arg.Figi,
		arg.InstrumentType,
		arg.Quantity,
		arg.Payment,
		arg.Currency,
		arg.Date,
		arg.AccountID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const OperationsByAccountId = `-- name: OperationsByAccountId :many
SELECT id, account_id, figi, instrument_type, payment, quantity, currency, date FROM investing.operations WHERE account_id = $1
`

func (q *Queries) OperationsByAccountId(ctx context.Context, accountID string) ([]*Operation, error) {
	rows, err := q.db.Query(ctx, OperationsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Operation{}
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Figi,
			&i.InstrumentType,
			&i.Payment,
			&i.Quantity,
			&i.Currency,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const OperationsByInstrument = `-- name: OperationsByInstrument :many
select id, account_id, figi, instrument_type, payment, quantity, currency, date from investing.operations where account_id = $1 and instrument_type = $2
`

type OperationsByInstrumentParams struct {
	AccountID      string `db:"account_id" json:"account_id"`
	InstrumentType string `db:"instrument_type" json:"instrument_type"`
}

func (q *Queries) OperationsByInstrument(ctx context.Context, arg OperationsByInstrumentParams) ([]*Operation, error) {
	rows, err := q.db.Query(ctx, OperationsByInstrument, arg.AccountID, arg.InstrumentType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Operation{}
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Figi,
			&i.InstrumentType,
			&i.Payment,
			&i.Quantity,
			&i.Currency,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const OperationsByInstrumentAndDateRange = `-- name: OperationsByInstrumentAndDateRange :many
SELECT id, account_id, figi, instrument_type, payment, quantity, currency, date FROM investing.operations
WHERE account_id = $1
  AND instrument_type = $2
  AND date BETWEEN $3 AND $4
`

type OperationsByInstrumentAndDateRangeParams struct {
	AccountID      string           `db:"account_id" json:"account_id"`
	InstrumentType string           `db:"instrument_type" json:"instrument_type"`
	Date           pgtype.Timestamp `db:"date" json:"date"`
	Date_2         pgtype.Timestamp `db:"date_2" json:"date_2"`
}

func (q *Queries) OperationsByInstrumentAndDateRange(ctx context.Context, arg OperationsByInstrumentAndDateRangeParams) ([]*Operation, error) {
	rows, err := q.db.Query(ctx, OperationsByInstrumentAndDateRange,
		arg.AccountID,
		arg.InstrumentType,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Operation{}
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Figi,
			&i.InstrumentType,
			&i.Payment,
			&i.Quantity,
			&i.Currency,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UserById = `-- name: UserById :one
select id, name, email from investing.users where id = $1
`

func (q *Queries) UserById(ctx context.Context, id pgtype.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, UserById, id)
	var i User
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return &i, err
}

const UserCreate = `-- name: UserCreate :one
insert into investing.users(name, email)
VALUES ($1, $2) returning id
`

type UserCreateParams struct {
	Name  string `db:"name" json:"name"`
	Email string `db:"email" json:"email"`
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, UserCreate, arg.Name, arg.Email)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
